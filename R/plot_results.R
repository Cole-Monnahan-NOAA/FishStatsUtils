
#' Plot results
#'
#' \code{plot_results} plots diagnostics, results, and indices for a given fitted model
#'
#' This function takes a fitted VAST model and generates a standard set of diagnostic and visualization plots.
#'
#' @param fit Output from \code{fit_model}
#' @inheritParams fit_model
#' @inheritParams plot_maps
#' @inheritParams plot_residuals
#' @inheritParams plot_range_edge
#' @param check_residuals Boolean indicating whether to run or skip residual diagnostic plots (which can be slow as currently implemented)
#' @param ... additional settings to pass to \code{FishStatsUtils::plot_maps}
#'
#' @return Invisibly returns a tagged list of outputs generated by standard plots.
#'
#' @family wrapper functions
#' @seealso \code{?VAST} for general documentation, \code{?make_settings} for generic settings, \code{?fit_model} for model fitting, and \code{?plot_results} for generic plots
#'
#' @export
plot_results = function( fit, settings=fit$settings, plot_set=3, working_dir=paste0(getwd(),"/"),
  year_labels=fit$year_labels, years_to_plot=fit$years_to_plot, use_biascorr=TRUE, map_list,
  category_names, check_residuals=TRUE, projargs='+proj=longlat', zrange, n_samples=100, ... ){

  # Check for known issues
  if( is.null(fit$Report)) stop("`fit$Report` is missing, please check inputs")
  if( missing(category_names)) category_names = 1:fit$data_list$n_c

  # Make directory
  dir.create(working_dir, showWarnings=FALSE, recursive=TRUE)

  # plot data
  message("\n### Making plots of data availability and knots")
  plot_data_args = list(...)
  plot_data_args = combine_lists( "input"=plot_data_args, "default"=list(Extrapolation_List=fit$extrapolation_list,
    Spatial_List=fit$spatial_list, Lat_i=fit$data_frame[,'Lat_i'], Lon_i=fit$data_frame[,'Lon_i'],
    Year_i=fit$data_frame[,'t_i'], PlotDir=working_dir, Year_Set=year_labels), "args_to_use"=formalArgs(plot_data) )
  Dens_xt = do.call( what=plot_data, args=plot_data_args )

  # PLot settings
  if( missing(map_list) ){
    message("\n### Obtaining default settings for plotting maps")
    map_list = make_map_info( "Region"=settings$Region, "spatial_list"=fit$spatial_list, "Extrapolation_List"=fit$extrapolation_list )
  }

  # Plot diagnostic for encounter probability
  message("\n### Making plot of encounter probability")
  Enc_prob = plot_encounter_diagnostic( Report=fit$Report, Data_Geostat=cbind("Catch_KG"=fit$data_frame[,'b_i']), DirName=working_dir)

  # Plot anisotropy
  message("\n### Making plot of anisotropy")
  plot_anisotropy( FileName=paste0(working_dir,"Aniso.png"), Report=fit$Report, TmbData=fit$data_list )

  # Plot index
  if( !is.null(fit$parameter_estimates$SD) ){
    message("\n### Making plot of abundance index")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_biomass_index` isn't built to handle non-numeric `year_labels`")
    Index = plot_biomass_index( DirName=working_dir, TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Year_Set=year_labels,
      Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names )
  }else{
    Index = "Not run"
    message("\n### Skipping plot of abundance index; must re-run with standard errors to plot")
  }

  # Plot comps
  if( !is.null(fit$parameter_estimates$SD) & fit$data_list$n_c>1 ){
    message("\n### Making plot of composition data")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_biomass_index` isn't built to handle non-numeric `year_labels`")
    Proportions = calculate_proportion( TmbData=fit$data_list, Index=Index, Year_Set=year_labels,
      Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names, DirName=working_dir )
    #Compositions = plot_biomass_index( DirName=working_dir, TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Year_Set=year_labels,
    #  Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names )
  }else{
    Proportions = "Not run"
    message("\n### Skipping plot of composition data; must re-run with standard errors and multiple categories to plot")
  }

  # Plot range indices
  if( !is.null(fit$parameter_estimates$SD) ){
    message("\n### Making plot of spatial indices")
    #if( !all(is.numeric(year_labels)) ) stop("`plot_range_index` isn't built to handle non-numeric `year_labels`")
    Range = plot_range_index(Report=fit$Report, TmbData=fit$data_list, Sdreport=fit$parameter_estimates$SD, Znames=colnames(fit$data_list$Z_xm),
      PlotDir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot, use_biascorr=use_biascorr, category_names=category_names )
  }else{
    Range = "Not run"
    message("\n### Skipping plot of spatial indices; must re-run with standard errors to plot")
  }

  # Plot range edges
  if( "jointPrecision"%in%names(fit$parameter_estimates$SD) & n_samples>0 ){
    message("\n### Making plot of range edges")
    Edge = plot_range_edge( Obj=fit$tmb_list$Obj, Sdreport=fit$parameter_estimates$SD,
      working_dir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot,
      category_names=category_names, n_samples=n_samples, quantiles=c(0.05,0.5,0.95) )
  }else{
    Edge = "Not run"
    message("\n### Skipping plot of range edge; only possible if `getJointPrecision=TRUE` and `n_samples`>0")
  }

  # Plot densities
  message("\n### Making plots of spatial predictions")
  # Including Report as input to plot_maps_args so that it doesn't need to re-run it when loading results without TMB linked
  plot_maps_args = list(...)
  plot_maps_args = combine_lists( "input"=plot_maps_args, "default"=list(plot_set=plot_set, category_names=category_names, TmbData=fit$data_list,
    Report=fit$Report, Sdreport=fit$parameter_estimates$SD, PlotDF=map_list[["PlotDF"]], MapSizeRatio=map_list[["MapSizeRatio"]],
    working_dir=working_dir, Year_Set=year_labels, Years2Include=years_to_plot, legend_x=map_list[["Legend"]]$x/100, legend_y=map_list[["Legend"]]$y/100,
    Obj=fit$tmb_list$Obj), "args_to_use"=formalArgs(plot_maps) )
  Dens_xt = do.call( what=plot_maps, args=plot_maps_args )

  # Plot quantile-quantile plot
  if( check_residuals == TRUE ){
    message("\n### Making Q-Q plot")
    Q = plot_quantile_diagnostic( TmbData=fit$data_list, Report=fit$Report, FileName_PP="Posterior_Predictive",
      FileName_Phist="Posterior_Predictive-Histogram", FileName_QQ="Q-Q_plot", FileName_Qhist="Q-Q_hist", save_dir=working_dir )

    # Pearson residuals
    message("\n### Making plot of Pearson residuals")
    plot_residuals(Lat_i=fit$data_frame[,'Lat_i'], Lon_i=fit$data_frame[,'Lon_i'], TmbData=fit$data_list, Report=fit$Report,
      Q=Q, working_dir=working_dir, spatial_list=fit$spatial_list, extrapolation_list=fit$extrapolation_list,
      Year_Set=year_labels, Years2Include=years_to_plot, zrange=zrange,
      legend_x=map_list[["Legend"]]$x/100, legend_y=map_list[["Legend"]]$y/100 )
  }else{
    Q = "Not run"
    message("\n### Skipping Q-Q plot")
    message("\n### Skipping plot of Pearson residuals")
  }

  # return
  Return = list( "Q"=Q, "Index"=Index, "Proportions"=Proportions, "Range"=Range, "Dens_xt"=Dens_xt, "Edge"=Edge,
    "map_list"=map_list, "plot_maps_args"=plot_maps_args )
  return( invisible(Return) )
}

